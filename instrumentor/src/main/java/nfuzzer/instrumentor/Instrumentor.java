package nfuzzer.instrumentor;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.io.IOUtils;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;

public class Instrumentor {

    public static ClassLoader classloader;

    public static void main(String[] args) throws Exception {
        // classloader
        classloader = Thread.currentThread().getContextClassLoader();

        Options options = Options.v();
        CmdLineParser parser = new CmdLineParser(options);

        try {
            parser.parseArgument(args);
        } catch (CmdLineException e) {
            parser.printUsage(System.err);
            return;
        }

        // 加载全部类文件
        Set<String> inputClasses = Options.v().getInput();

        Set<String> skipped = new HashSet<>();

        for (String cls : inputClasses) {
            recordLog.writeLog("Instrumenting class: " + cls);
//			System.out.println("Instrumenting class: " + cls);
            InputStream bytecode = classloader.getResourceAsStream(cls);
            if (bytecode == null) {
                System.err.println("class file not found: " + cls);
                return;
            }
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
            ClassTransformer ct = new ClassTransformer(cw, options.getSp());
            ClassReader cr;
            cr = new ClassReader(bytecode);

            try {
                cr.accept(ct, 8);
                byte[] bytes = cw.toByteArray();
                writeClass(cls, bytes);
            } catch (RuntimeException rte) {
                if (rte.getMessage().contains("JSR/RET")) {

                    //
                    recordLog.writeLog("\n[WARNING] RuntimeException during instrumentation: " + rte.getMessage());
                    recordLog.writeLog("Skipping instrumentation of class " + cls + "\n");
                    //System.out.println("\n[WARNING] RuntimeException during instrumentation: " + rte.getMessage());
                    //System.out.println("Skipping instrumentation of class " + cls + "\n");

                    loadAndWriteResource(cls);
                    skipped.add(cls);
                } else {
                    throw rte;
                }
            }

        }

        String[] resources = {"nfuzzer/Nfuzzer.class",
                "nfuzzer/Nfuzzer$1.class",
                "nfuzzer/Nfuzzer$2.class",
                "nfuzzer/Nfuzzer$ApplicationCall.class",
                "nfuzzer/Nfuzzer$FuzzRequest.class",
                "nfuzzer/Nfuzzer$NullOutputStream.class",
                "nfuzzer/Mem.class",
                "nfuzzer/socket/CovSend.class",
                "nfuzzer/socket/CovSendThread.class"};

        for (String resource : resources) {
            loadAndWriteResource(resource);
        }

        if (skipped.size() > 0) {

            recordLog.writeLog("\nWARNING!!! Instrumentation of some classes has been skipped.");
            recordLog.writeLog("This is due to the JSR/RET bytecode construct that is not supported by ASM.");
            recordLog.writeLog("It is deprecated and should not be present in bytecode generated by a recent compiler.");
            recordLog.writeLog("If this is your code, try using a different compiler.");
            recordLog.writeLog(
                    "If this is a library, there might be not too much harm in skipping instrumentation of these classes.");
            recordLog.writeLog("Classes that were skipped:");

            //System.out.println("\nWARNING!!! Instrumentation of some classes has been skipped.");
            //System.out.println("This is due to the JSR/RET bytecode construct that is not supported by ASM.");
            //System.out
            //		.println("It is deprecated and should not be present in bytecode generated by a recent compiler.");
            //System.out.println("If this is your code, try using a different compiler.");
            //System.out.println(
            //		"If this is a library, there might be not too much harm in skipping instrumentation of these classes.");
            //System.out.println("Classes that were skipped:");
            //for (String cls : skipped)
            //	recordLog.writeLog(cls);
            //System.out.println(cls);
        }
    }

    private static void writeClass(String cls, byte[] bytes) throws Exception {
        String path = Options.v().getOutput().endsWith("/") ?
                Options.v().getOutput() + cls :
                Options.v().getOutput() + "/" + cls;
        Path out = Paths.get(path);
        try {
            Files.createDirectories(out.getParent());
            Files.write(out, bytes);

            recordLog.writeLog("File written: " + path);
            //System.out.println("File written: " + path);
        } catch (IOException e) {
            recordLog.writeLog("Error writing to file: " + path);
            //System.err.println("Error writing to file: " + path);
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void loadAndWriteResource(String resource) throws Exception {
        InputStream is = classloader.getResourceAsStream(resource);
        if (is == null) {

            recordLog.writeLog("Error loading classes for addition to output");
            //System.err.println("Error loading classes for addition to output");
            return;
        }
        byte[] rbytes;
        try {
            rbytes = IOUtils.toByteArray(is);
        } catch (IOException e) {

            recordLog.writeLog("Error loading classes for addition to output");
            //System.err.println("Error loading classes for addition to output");
            e.printStackTrace();
            return;
        }
        writeClass(resource, rbytes);
    }
}
